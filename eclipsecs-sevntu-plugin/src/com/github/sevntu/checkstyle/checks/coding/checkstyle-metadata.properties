AvoidConstantAsFirstOperandInCondition.name = Avoid Constant As First Operand In Condition
AvoidConstantAsFirstOperandInCondition.desc = If comparing values, C(C++) developers prefer to put the constant first in the equality check, to prevent situations of assignment rather than equality checking.<br><br>But in Java, in IF condition it is impossible to use assignment, so that habit become unnecessary and do damage readability of code.<br><br>In C(C++), comparison for null is tricky, and it is easy to write "=" instead of "==", and no complication error will be but condition will work in different way<br><br>Example:<br><code>if (null == variable)</code><br>rather than<br><code>if (variable == null)</code><br>because if you forget one (typo mistake) of the equal sign, you end up with<br><code>if (variable = null)</code><br>which assigns null to variable and IF always evaluate to true.
AvoidConstantAsFirstOperandInCondition.targetConstantTypes = Target Constant Types

AvoidDefaultSerializableInInnerClasses.name = Avoid default implementation of serializable interface
AvoidDefaultSerializableInInnerClasses.desc = This check prevents the default implementation Serializable interface in inner classes (Serializable interface are default if methods readObject() or writeObject() are not override in class). Check has option, that allow implementation only one method, if it true, but if it false - class must implement both methods. For more information read &quot;Effective Java (2nd edition)&quot; chapter 11, item 74, page 294.

AvoidHidingCauseException.name = Avoid Hiding Cause of the Exception
AvoidHidingCauseException.desc = Warns when you try to hide cause of an exception when rethrowing

AvoidNotShortCircuitOperatorsForBoolean.name = Avoid using bitwise operations for boolean expressions
AvoidNotShortCircuitOperatorsForBoolean.desc = Avoid using bitwise operations for boolean expressions

AvoidModifiersForTypes.name = Avoid Modifiers For Types
AvoidModifiersForTypes.desc = Disallow some set of modifiers for Java types specified by regexp.<br><br>Only 4 types according to Java Spec: static, final, transient, volatile.<br><br>Example:<br>"static" modifier for ULCComponents (http://ulc-community.canoo.com/snipsnap/space/Good+Practices) is not allowed.<br>So we can disallow "static" modifier for all ULC* components by setting up "forbiddenClassesRegexpStatic" option to "ULC.+" regexp String.
AvoidModifiersForTypes.forbiddenClassesRegexpFinal = The regexp defines the names of classes, that could not have 'final' modifier.
AvoidModifiersForTypes.forbiddenClassesRegexpStatic = The regexp defines the names of classes, that could not have 'static' modifier.
AvoidModifiersForTypes.forbiddenClassesRegexpTransient = The regexp defines the names of classes, that could not have 'transient' modifier.
AvoidModifiersForTypes.forbiddenClassesRegexpVolatile = The regexp defines the names of classes, that could not have 'volatile' modifier.

CustomDeclarationOrder.name = Custom Declaration Order
CustomDeclarationOrder.desc = <p>Checks that the parts of a class(main, nested, member inner) declaration appear in the rules order set by user using regular expressions.<p>The check forms line which consists of class member annotations, modifiers,type and name from your code and compares it with your RegExp.</p>The rule consists of:*<pre>ClassMember(RegExp)</pre></p>To set class order use the following notation of the class members (case insensitive):<p><ol><li>"Field" to denote the Fields</li><li>"DeclareAnnonClassField" to denote the fields keeping objects of anonymous classes</li><li>"Ctor" to denote the Constructors</li><li>"Method" to denote the Methods</li><li>"GetterSetter" to denote the group of getter and setter methods</li><li>"MainMethod" to denote the main method</li><li>"InnerClass" to denote the Inner Classes</li><li>"InnerInterface" to denote the Inner Interfaces</li><li>"InnerEnum" to denote the Inner Enums</li></ol></p>RegExp can include:<p><ol><li>Annotations</li><li>Modifiers(public, protected, private, abstract, static,final)</li><li>Type</li><li>Name</li></ol></p>ATTENTION!<p>Use separator <code>' ', '.', '\s'</code> between declaration in the RegExp.</p><pre>Example:     Field(public.*final.*)     Field(public final.*)     Field(public<code>\s*</code>final.*)</pre>NOTICE!<p>It is important to write exact order of modifiers in rules. So rule<code><i>Field(public final)</i></code> does not match to <code><i>final public value;</i></code>.<a href='http://checkstyle.sourceforge.net/config_modifier.html#ModifierOrder'>ModifierOrderCheck</a>is recommended to use.</p><p>If you set empty RegExp e.g. <code>Field()</code>, it means that class member doesn't have modifiers(default modifier) and checking the type and name of member doesn't occur.</p><p>Between the declaration of a array and generic can't be whitespaces.E.g.: <code>ArrayList&lt;String[]&gt; someName</code></p><p>Use the separator '###' between the class declarations.</p><p>For Example:</p><p><code>Field(private static final long serialVersionUID) ###Field(public static final.*) ### Field(.*private.*) ### Ctor(.*) ###GetterSetter(.*) ### Method(.*public.*final.*|@Ignore.*public.*) ###Method(public static.*(final|(new|edit|create).*).*) ###InnerClass(public abstract.*) ### InnerInterface(.*) ### InnerEnum(.*)</code></p> *<p><b>What is group of getters and setters(<code>GetterSetter</code>)?</b></p><p>It is ordered sequence of getters and setters like:<pre>public int getValue() {    log.info("Getting value");    return value;} *public void setValue(int newValue) {    value = newValue;} *public Object getObj() {   return obj;} *public void setObj(Object obj) {   if (obj != null) {     this.obj = obj;   } else {     throw new IllegalArgumentException("Null value");   }} *...</pre></p><p>Getter is public method that returns class field. Name of getter should be'get<i>FieldName</i>' in camel case.</p><p>Setter is public method with one parameter that assigns this parameter to class field. Name of setter should be 'set<i>FieldName</i>' in camel case.</p><p>Setter of field X should be right after getter of field X.</p> *@author <a href="mailto:solid.danil@gmail.com">Danil Lopatin</a>@author <a href="mailto:barataliba@gmail.com">Baratali Izmailov</a>
CustomDeclarationOrder.fieldPrefix = Prefix of field's name.
CustomDeclarationOrder.customDeclarationOrder = Regular expression, which sets the order of the parts of a class(main, nested, member inner).
CustomDeclarationOrder.caseSensitive = Set false to ignore case.

ConfusingConditionCheck.name = Confusing Condition
ConfusingConditionCheck.desc = This check prevents negation within an "if" expression if "else" is present.<br>For example, rephrase: <br> if (x != y) smth1();<br> else smth2(); <br>as:<br> if (x == y) smth2(); <br>else smth1();
ConfusingConditionCheck.multiplyFactorForElseBlocks = Disable warnings if "else" block length is in "multiplyFactorForElseBlocks"  time less then "if" block.
ConfusingConditionCheck.ignoreInnerIf = Disable warnings for all inner "if" . It is useful for save similarity.
ConfusingConditionCheck.ignoreSequentialIf = Disable warnings for all sequential "if" . It is useful for save similarity.
ConfusingConditionCheck.ignoreNullCaseInIf = Disable warnings for "if" if it expression contains "null".
ConfusingConditionCheck.ignoreThrowInElse = Disable warnings for "if" if "else" block contain "throw".

FinalizeImplementationCheck.name = Finalize Implementation
FinalizeImplementationCheck.desc = <p>This Check detects 3 most common cases of incorrect finalize() method implementation:</p><ul><li>negates effect of superclass finalize<br/><code>protected void finalize() { } <br/> protected void finalize() { doSomething(); }</code></li><li>useless (or worse) finalize<br/><code>protected void finalize() { super.finalize(); }</code></li><li>public finalize<br/><code>public void finalize() { try { doSomething(); } finally { super.finalize() } }</code></li></ul>

ForbidCertainImports.name = Forbid Certain Imports
ForbidCertainImports.desc = Forbids certain imports usage in certain packages. <br/><br/>You can configure this check using following parameters:<ol><li>Package qualified name regexp;</li><li>Forbidden imports regexp;</li><li>Forbidden imports excludes regexp.</li></ol>This check reads packages and imports qualified names without words "package","import" and semicolons, so, please, do NOT include "package" or "import" words or semicolons into your regular expressions when configuring.<br/><br/>Real-life example of usage: forbid to use all "*.ui.*" packages in "*.dao.*" packages, but ignore all Exception imports (such as <b>org.springframework.dao.InvalidDataAccessResourceUsageException</b>). For doing that, you should use the following check parameters: <br/><br/><dl><li>Package name regexp = ".*ui.*"</li><li>Forbidden imports regexp = ".*dao.*"</li><li>Forbidden imports excludes regexp = "^.+Exception$"</li></dl><br/>By means of few instances of this check will be possible to cover any rules.<br/><br/>Author: <a href="https://github.com/daniilyar"> Daniil Yaroslavtsev</a>
ForbidCertainImports.packageNameRegexp = Package name regexp.
ForbidCertainImports.forbiddenImportsRegexp = Regexp for matching forbidden imports
ForbidCertainImports.forbiddenImportsExcludesRegexp = Regexp for excluding imports from checking

ForbidInstantiation.name = Forbid Instantiation
ForbidInstantiation.desc = Forbids instantiation of certain object types by their full classname.<br><p>For example:<br>"java.lang.NullPointerException" will forbid the NPE instantiation.</p><p>Note: className should to be full: use "java.lang.NullPointerException" instead of "NullpointerException".</p>
ForbidInstantiation.forbiddenClasses = ClassNames for objects that are forbidden to instantiate.

ForbidCCommentsInMethods.name = Forbid C comments in method body
ForbidCCommentsInMethods.desc = Forbid C-style comments (/* ... */) in method body.

ForbidReturnInFinalBlockCheck.name = Forbid return statement in finally block
ForbidReturnInFinalBlockCheck.desk = Verifies the finally block design

ForbidThrowAnonymousExceptionsCheck.name = Forbid Throw Anonymous Exceptions
ForbidThrowAnonymousExceptionsCheck.desc = <p>This Check warns on throwing anonymous exception.<br>Examples:<p><code><pre> catch (Exception e)  {<br>     throw new RuntimeException()  {  //WARNING<br>          //some code<br>     };<br> }<br><br> catch (Exception e)  {<br>     RuntimeException run = new RuntimeException()  {<br>          //some code<br>     };<br>     throw run;  //WARNING<br> }<br></code></pre>The distinguishing of <b>exception</b> types occurs by analyzing variable's class's name.<br>Check has an option which contains the regular expression for exception class name matching<br>Default value is "^.*Exception" because usually exception type ends with suffix "Exception".<br>Then, if we have an ObjBlock (distinguished by curly braces), it's anonymous<br>exception definition. It could be defined in <b>throw</b> statement immediately.<br>In that case, after literal new, there would be an expression type finishing with and ObjBlock.<br><br>@author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a><br>@author <a href="mailto:maxvetrenko2241@gmail.com">Max Vetrenko</a>
ForbidThrowAnonymousExceptionsCheck.exceptionClassNameRegex = Regex for exception class name matching

DiamondOperatorForVariableDefinitionCheck.name = Diamond Operator For Variable Definition
DiamondOperatorForVariableDefinitionCheck.desc = This Check highlights variable definition statements where <a href= "http://docs.oracle.com/javase/7/docs/technotes/guides/language/type-inference-generic-instance-creation.html"> diamond operator</a> could be used.<br> <b>Rationale</b>: using diamond operator (introduced in Java 1.7) leads to shorter code<br> and better code readability. It is suggested by Oracle that the diamond primarily using<br> for variable declarations.<br><br> E.g. of statements: <p> <b>Without diamond operator:</b><br><code> Map&ltString, Map&ltString, Integer&gt&gt someMap = new HashMap&ltString, Map&ltString, Integer&gt&gt();</code><br> <b>With diamond operator:</b><br> <code> Map&ltString, Map&ltString, Integer&gt&gt someMap = new HashMap&lt&gt(); </code> </p> @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>

IllegalCatchExtended.name = Illegal Catch Extended
IllegalCatchExtended.desc = Check for illegal catch but with option to ignore these catches in some cases
IllegalCatchExtended.allowThrow = Allow catching when throwing some exception
IllegalCatchExtended.allowRethrow = Allow catching when re-throwing exception

LogicConditionNeedOptimizationCheck.name = Logic condition need optimization
LogicConditionNeedOptimizationCheck.desc = This check prevents the placement of local variables and fields after calling methods in '&&' and '||' conditions.

MapIterationInForEachLoop.name = Map Iteration In For Each Loop 
MapIterationInForEachLoop.desc = This check can help you to write the whole for-each map iteration more correctly:<ol><li> If you iterate over a map using map.keySet() or map.entrySet(), but your code uses only map values, Check will propose you to use map.values() instead of map.keySet() or map.entrySet(). Replacing map.keySet() or map.entrySet() with map.values() for such cases can a bit improve an iteration performance. <p>Bad:</p><pre>for (Map.Entry<String, String>; entry : map.entrySet()){<br/>   System.out.println(entry.getValue());<br/>}</pre><pre>for (String key : map.keySet(){<br/>   System.out.println(map.get(key));<br/>}</pre><p>Good:</p><pre>for (String value : map.values()){<br/>   System.out.println(value);<br/>}</pre> </li><li>If you iterate over a map using map.entrySet(), but never call entry.getValue(), Check will propose you to use map.keySet() instead of map.entrySet(). to iterate over map keys only. <p>Bad:</p><pre>for (Map.Entry<String, String> entry : map.entrySet()){<br/>   System.out.println(entry.getKey());<br/>}</pre><p>Good:</p><pre>for (String key : map.keySet()){<br/>   System.out.println(key);<br/>}</pre></li><li>If you iterate over a map with map.keySet() and use both keys and values, check will propose you to use map.entrySet() to improve an iteration performance by avoiding search operations inside a map. For this case, iteration can significantly grow up a performance. <p>Bad:</p><pre>for (String key : map.keySet()){<br/>   System.out.println(key + "  " + map.get(key));<br/>}</pre><p>Good:</p><pre>for (Map.Entry<String, String> entry : map.entrySet()){<br/>   System.out.println(entry.getValue() + "   " + entry.getKey());<br/>}</pre></li></ol>
MapIterationInForEachLoop.supportedMapImplQualifiedNames = Enter your own Map implementations.
MapIterationInForEachLoop.proposeValuesUsage = If this checkbox is checked, Check will propose to replace wrong usage to value().
MapIterationInForEachLoop.proposeKeySetUsage = If this checkbox is checked, Check will propose to replace wrong usage to keySet().
MapIterationInForEachLoop.proposeEntrySetUsage = If this checkbox is checked, Check will propose to replace wrong usage to entrySet().

MultipleVariableDeclarationsExtended.name = Multiple Variable Declarations Extended
MultipleVariableDeclarationsExtended.desc = Warn when declaring several variables in one line
MultipleVariableDeclarationsExtended.ignoreCycles = Turning on this option makes check not to warn on multiple variable definitions inside cycles.   
MultipleVariableDeclarationsExtended.ignoreMethods = Turning on this option makes check not to warn on multiple variable definitions inside methods.

MultipleStringLiteralsExtended.allowedDuplicates       = The maximum number of occurences to allow without generating a warning
MultipleStringLiteralsExtended.desc                    = Checks for multiple occurrences of the same string literal within a single file.<br/>\r\nRationale: Code duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.
MultipleStringLiteralsExtended.ignoreOccurrenceContext = Token type names where duplicate strings are ignored even if they don't match ignoredStringsRegexp. This allows you to exclude syntactical contexts like Annotations or static initializers from the check.
MultipleStringLiteralsExtended.ignoreStringsRegexp     = Regexp pattern for ignored strings (with quotation marks)
MultipleStringLiteralsExtended.name                    = Multiple String Literals Extended
MultipleStringLiteralsExtended.highlightAllDuplicates  = Check to highlight all dublicates

TernaryPerExpressionCountCheck.name = Ternary Per Expression Count
TernaryPerExpressionCountCheck.desc = Restricts the number of ternary operators in expression to a specific limit.<br><br><b>Rationale:</b> This Check helps to improve code readability by pointing developer on<br>expressions which contain more than user-defined count of ternary operators.<br><br>It points to complicated ternary <a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html">expressions</a>. Reason:<br>- Complicated ternary expressions are not easy to read.<br>- Complicated ternary expressions could lead to ambiguous result if user<br>does not know Java's operators priority well, e.g.:<br><p><code>String str = null;<br>String x = str != null ? "A" : "B" + str == null ? "C" : "D";<br>System.out.println(x);</code></p>Output for code above is "D", but more obvious would be "BC".<br></p>Check has following properties:<br><ul><li><b>maxTernaryPerExpressionCount</b> - limit of ternary operators perexpression<br></li><li><b>ignoreTernaryOperatorsInBraces</b> - if true Check will ignore ternary operators<br>in braces (braces explicitly set priority level)<br></li><li><b>ignoreIsolatedTernaryOnLine</b> - if true Check will ignore one line ternary operators,<br>if only it is places in line alone.<br> </li></ul>Options <b>ignoreTernaryOperatorsInBraces</b> and <b>ignoreIsolatedTernaryOnLine</b> can<br>make Check less strict, e.g.:<br>Using <b>ignoreTernaryOperatorsInBraces</b> option (value = <b>true</b>)<br>does not put violation on code below:<br><p><code><pre>callString = "{? = call " +<br>  (StringUtils.hasLength(catalogNameToUse)   ? catalogNameToUse + "." : "") +<br>  (StringUtils.hasLength(schemaNameToUse)   ? schemaNameToUse + "." : "") +<br>  procedureNameToUse + "(";<br></pre></code></p>When using <b>ignoreIsolatedTernaryOnLine</b> (value = <b>true</b>), even without<br><b>ignoreTernaryOperatorsInBraces</b> option Check won't warn on code below:<br> <p><code><pre>int a = (d == 5) ? d : f<br>  +<br>  ((d == 6) ? g : k);</pre></code></p>@author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
TernaryPerExpressionCountCheck.maxTernaryPerExpressionCount = Maximum number of ternary operators in expression
TernaryPerExpressionCountCheck.ignoreTernaryOperatorsInBraces = Ignore ternary operators in expression in case if priority level is set explicitly
TernaryPerExpressionCountCheck.ignoreIsolatedTernaryOnLine = Ignore ternary operators in expression in case if ternary operator is isolated in line 

NoMainMethodInAbstractClass.name = No Main Method In Abstract Class
NoMainMethodInAbstractClass.desc = Checks if an abstract class does not have "main()" method, because it can mislead a developer to consider this class as a ready-to-use implementation

NoNullForCollectionReturnCheck.name = No null for collection return
NoNullForCollectionReturnCheck.desc = Check report you, when method, that must return array or collection, return null value instead of empty collection or empty array.
NoNullForCollectionReturnCheck.collectionList = List of the collections that will be check
NoNullForCollectionReturnCheck.searchThroughMethodBody = Search null value not only into return block

OverridableMethodInConstructor.desc = <p>Prevents any calls to overridable methods that are take place in:<ol><li>Any constructor body (verification is always done by default and not configurable).<li>Any method which works same as a constructor: clone() method from Cloneable interface and readObject() method from Serializable interface (you can individually switch on/of these methods verification by changing CheckCloneMethod and CheckReadObjectMethod properties).</li></ol><p>Rationale:<ol><li><q>Constructors must not invoke overridable methods, directly or indirectly.If you violate this rule, program failure will result. The superclass constructor runs before the subclass constructor, so the overriding method in the subclass will be invoked before the subclass constructor has run. If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected.</q><li><q>If you do decide to implement Cloneable or Serializable in a class designed for inheritance, you should be aware that because the clone() and readObject() methods behave a lot like constructors, a similar restriction applies: neither clone nor readObject may invoke an overridable method, directly or indirectly.</q></ol></p><br><p align="right">[Joshua Bloch - Effective Java 2nd Edition,Chapter 4, Item 17]</p><br>
OverridableMethodInConstructor.name = Overridable Method In Constructor
OverridableMethodInConstructor.checkCloneMethod = Enables the searching of calls to overridable methods from body of any clone() method is implemented from Cloneable interface.
OverridableMethodInConstructor.checkReadObjectMethod = Enables the searching of calls to overridable methods from the body of any readObject() method is implemented from Serializable interface.
OverridableMethodInConstructor.matchMethodsByArgCount = Enables matching methods by number of their parameters

ReturnBooleanFromTernary.name = Returning Boolean from Ternary Operator
ReturnBooleanFromTernary.desc = Avoid returning boolean values from ternary operator - use the boolean value from the inside directly.

ReturnCountExtended.name=Return Count Extended
ReturnCountExtended.desc=Checks that method/ctor "return" literal count is not greater than the given value ("maxReturnCount" property).<br><br>Rationale:<br><br>One return per method is a good practice as its ease understanding of method logic.<br><br>Reasoning is that:<dl><li>It is easier to understand control flow when you know exactly where the method returns.<li>Methods with 2-3 or many "return" statements are much more difficult to understand, debug and refactor.</dl>Setting up the check options will make it to ignore:<ol><li>Methods by name ("ignoreMethodsNames" property). Note, that the "ignoreMethodsNames" property type is NOT regexp: using this property you can list the names of ignored methods separated by comma.</li><li>Methods which linelength less than given value ("linesLimit" property).<li>"return" statements which depth is greater or equal to the given value ("returnDepthLimit" property). There are few supported<br>coding blocks when depth counting: "if-else", "for", "while"/"do-while" and "switch".<li>"Empty" return statements = return statements in void methods and ctors that have not any expression ("ignoreEmptyReturns" property).<li>Return statements, which are located in the top lines of method/ctor (you can specify the count of top method/ctor lines that will be ignored using "rowsToIgnoreCount" property).</ol>So, this is much improved version of the existing <i>Return Count</i> check.<br><br>
ReturnCountExtended.maxReturnCount=maximum allowed number of return statements per method/ctor (1 by default).
ReturnCountExtended.ignoreMethodLinesCount=Option to ignore methods/ctors which body has the linelength is less than given (20 lines by default). Set "0" to switch this option off and check all methods/ctors.
ReturnCountExtended.minIgnoreReturnDepth=Option to ignore methods/ctors that have return statement(s) with depth value is less than N levels(scopes). 4 by default. 0 is the min depth. Depth is 0 when the "return" statement is not wrapped on one of the supported coding blocks. 
ReturnCountExtended.ignoreEmptyReturns=Option to ignore "empty" (with no any expression) return statements in void methods and ctors. 'False' by default.
ReturnCountExtended.topLinesToIgnoreCount=Option to set the count of code lines that will be ignored in top of all methods.
ReturnCountExtended.ignoreMethodsNames=Option to set the RegExp patterns for methods' names which would be ignored by check.

ReturnNullInsteadOfBoolean.name = Returning Null Instead of Boolean
ReturnNullInsteadOfBoolean.desc = Method declares to return Boolean, but returns null

RedundantReturnCheck.name=Redundant Return
RedundantReturnCheck.desc=Check code for presence of redundant return
RedundantReturnCheck.allowReturnInEmptyMethodsAndConstructors=If True, allow 'return' in empty constructors and methods that return void.

SimpleAccessorNameNotationCheck.name=Simple Accessor Name Notation
SimpleAccessorNameNotationCheck.desc=This check verify incorrect name of setter or getter methods if it used field with other name. For example, method has name 'setXXX', but define field with name 'YYY'
SimpleAccessorNameNotationCheck.prefix=prefix of field's name

UnnecessaryParenthesesExtended.desc = Checks for the use of unnecessary parentheses.
UnnecessaryParenthesesExtended.name = Unnecessary Parentheses Extended
UnnecessaryParenthesesExtended.ignoreCalculationOfBooleanVariables =           Cancel validation setups of unnecessary parentheses in Boolean computations.
UnnecessaryParenthesesExtended.ignoreCalculationOfBooleanVariablesWithReturn = Cancel validation setups of unnecessary parentheses in Boolean computations with return state.
UnnecessaryParenthesesExtended.ignoreCalculationOfBooleanVariablesWithAssert = Cancel validation setups of unnecessary parentheses in Boolean computations with assert state.

EitherLogOrThrowCheck.desc =  <p>Either log the exception, or throw it, but never do both. Logging and throwing results in multiple log messages for a single problem in the code, and makes problems for the support engineer who is trying to dig through the logs. This is one of the most annoying error-handling antipatterns. All of these examples are equally wrong.</p><p><b>Examples:</b><pre>catch (NoSuchMethodException e) {\t\nLOG.error("Message", e);\t\nthrow e;\n}</pre><b>or</b><pre>catch (NoSuchMethodException e) {\t\nLOG.error("Message", e);\t\nthrow new MyServiceException("AnotherMessage", e);\n}</pre><b>or</b><pre>catch (NoSuchMethodException e) {\t\ne.printStackTrace();\t\nthrow new MyServiceException("Message", e);\n}</pre></p><p><b>What check can detect:</b> <br><b>Loggers</b><ul><li>logger is declared as class field</li><li>logger is declared as method's local variable</li><li>logger is declared as local variable in <code>catch</code> block</li><li>logger is passed through method's parameters</li></ul><b>Exceptions</b><ul><li>logger logs <code>catch</code> parameter exception or it's message</li><li>throw <code>catch</code> parameter exception</li><li>throw another exception which is based on <code>catch</code> parameter exception</li><li>printStackTrace was called on <code>catch</code> parameter exception</li></ul></p><b>What check can not detect:</b> <br><ul><li>loggers that is used like method's return value. Example:<pre>getLogger().error(&quot;message&quot;, e)</pre></li> <li>loggers that is used like static fields from another classes:<pre>MyAnotherClass.LOGGER.error("message", e);<pre></li></ul></p><p>Default parameters are:<ul><li><b>loggerFullyQualifiedClassName</b> - fully qualified class name of logger type. Default value is <i>"org.slf4j.Logger"</i>.</li><li><b>loggingMethodNames</b> - comma separated names of logging methods. Default value is <i>"error, warn, info, debug"</i>.</li></ul></p><p>Note that check works with only one logger type. If you have multiple different loggers, then create another instance of this check.</p>
EitherLogOrThrowCheck.name = Either log exception or throw exception.
EitherLogOrThrowCheck.loggerFullyQualifiedClassName = Logger fully qualified class name. Example: "org.slf4j.Logger".
EitherLogOrThrowCheck.loggingMethodNames = Logging method names separated with commas. Example: "error,warn". 
