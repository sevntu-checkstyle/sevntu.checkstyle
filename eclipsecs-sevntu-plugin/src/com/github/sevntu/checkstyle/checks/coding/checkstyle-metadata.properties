AvoidConstantAsFirstOperandInConditionCheck.name = Avoid Constant As First Operand In Condition
AvoidConstantAsFirstOperandInConditionCheck.desc = If comparing values, C(C++) developers prefer to put the constant first in the equality check, to prevent situations of assignment rather than equality checking.<br><br>But in Java, in IF condition it is impossible to use assignment, so that habit become unnecessary and do damage readability of code.<br><br>In C(C++), comparison for null is tricky, and it is easy to write "=" instead of "==", and no complication error will be but condition will work in different way<br><br>Example:<br><code>if (null == variable)</code><br>rather than<br><code>if (variable == null)</code><br>because if you forget one (typo mistake) of the equal sign, you end up with<br><code>if (variable = null)</code><br>which assigns null to variable and IF always evaluate to true.
AvoidConstantAsFirstOperandInConditionCheck.targetConstantTypes = Target Constant Types

AvoidDefaultSerializableInInnerClassesCheck.name = Avoid default implementation of serializable interface
AvoidDefaultSerializableInInnerClassesCheck.desc = This check prevents the default implementation Serializable interface in inner classes (Serializable interface are default if methods readObject() or writeObject() are not override in class). Check has option, that allow implementation only one method, if it true, but if it false - class must implement both methods. For more information read &quot;Effective Java (2nd edition)&quot; chapter 11, item 74, page 294.
AvoidDefaultSerializableInInnerClassesCheck.allowPartialImplementation = Allow partial implementation for serializable interface

AvoidHidingCauseExceptionCheck.name = Avoid Hiding Cause of the Exception
AvoidHidingCauseExceptionCheck.desc = Warns when you try to hide cause of an exception when rethrowing

AvoidNotShortCircuitOperatorsForBooleanCheck.name = Avoid using bitwise operations for boolean expressions
AvoidNotShortCircuitOperatorsForBooleanCheck.desc = Avoid using bitwise operations for boolean expressions

AvoidModifiersForTypesCheck.name = Avoid Modifiers For Types
AvoidModifiersForTypesCheck.desc = Disallow some set of modifiers for Java types specified by regexp.<br><br>Only 4 types according to Java Spec: static, final, transient, volatile.<br><br>Example:<br>"static" modifier for ULCComponents (http://ulc-community.canoo.com/snipsnap/space/Good+Practices) is not allowed.<br>So we can disallow "static" modifier for all ULC* components by setting up "forbiddenClassesRegexpStatic" option to "ULC.+" regexp String.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpAnnotation = The regexp defines the names of classes, that could not have 'Annotation' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpFinal = The regexp defines the names of classes, that could not have 'final' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpStatic = The regexp defines the names of classes, that could not have 'static' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpTransient = The regexp defines the names of classes, that could not have 'transient' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpVolatile = The regexp defines the names of classes, that could not have 'volatile' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpPrivate = The regexp defines the names of classes, that could not have 'private' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpPackagePrivate = The regexp defines the names of classes, that could not have 'package-private' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpProtected = The regexp defines the names of classes, that could not have 'protected' modifier.
AvoidModifiersForTypesCheck.forbiddenClassesRegexpPublic = The regexp defines the names of classes, that could not have 'public' modifier.

CustomDeclarationOrderCheck.name = Custom Declaration Order
CustomDeclarationOrderCheck.desc = <p>Checks that the parts of a class(main, nested, member inner) declaration appear in the rules order set by user using regular expressions.<p>The check forms line which consists of class member annotations, modifiers,type and name from your code and compares it with your RegExp.</p>The rule consists of:*<pre>ClassMember(RegExp)</pre></p>To set class order use the following notation of the class members (case insensitive):<p><ol><li>"Field" to denote the Fields</li><li>"DeclareAnnonClassField" to denote the fields keeping objects of anonymous classes</li><li>"Ctor" to denote the Constructors</li><li>"Method" to denote the Methods</li><li>"GetterSetter" to denote the group of getter and setter methods</li><li>"MainMethod" to denote the main method</li><li>"InnerClass" to denote the Inner Classes</li><li>"InnerInterface" to denote the Inner Interfaces</li><li>"InnerEnum" to denote the Inner Enums</li></ol></p>RegExp can include:<p><ol><li>Annotations</li><li>Modifiers(public, protected, private, abstract, static,final)</li><li>Type</li><li>Name</li></ol></p>ATTENTION!<p>Use separator <code>' ', '.', '\s'</code> between declaration in the RegExp. Whitespace should be added after each modifier.</p><pre>Example:     Field(public .*final .*)     Field(public final .*)     Field(public<code>\s*</code>final .*)</pre>NOTICE!<p>It is important to write exact order of modifiers in rules. So rule<code><i>Field(public final)</i></code> does not match to <code><i>final public value;</i></code>.<a href='http://checkstyle.sourceforge.net/config_modifier.html#ModifierOrder'>ModifierOrderCheck</a>is recommended to use.</p><p>If you set empty RegExp e.g. <code>Field()</code>, it means that class member doesn't have modifiers(default modifier) and checking the type and name of member doesn't occur.</p><p>Between the declaration of a array and generic can't be whitespaces.E.g.: <code>ArrayList&lt;String[]&gt; someName</code></p><p>Use the separator '###' between the class declarations.</p><p>For Example:</p><p><code>Field(private static final long serialVersionUID) ###Field(public static final .*) ### Field(.*private .*) ### Ctor(.*) ###GetterSetter(.*) ### Method(.*public .*final .*|@Ignore.*public .*) ###Method(public static .*(final|(new|edit|create).*).*) ###InnerClass(public abstract .*) ### InnerInterface(.*) ### InnerEnum(.*)</code></p> *<p><b>What is group of getters and setters(<code>GetterSetter</code>)?</b></p><p>It is ordered sequence of getters and setters like:<pre>public int getValue() {    log.info("Getting value");    return value;} *public void setValue(int newValue) {    value = newValue;} *public Object getObj() {   return obj;} *public void setObj(Object obj) {   if (obj != null) {     this.obj = obj;   } else {     throw new IllegalArgumentException("Null value");   }} *...</pre></p><p>Getter is public method that returns class field. Name of getter should be'get<i>FieldName</i>' in camel case.</p><p>Setter is public method with one parameter that assigns this parameter to class field. Name of setter should be 'set<i>FieldName</i>' in camel case.</p><p>Setter of field X should be right after getter of field X.</p> *@author <a href="mailto:solid.danil@gmail.com">Danil Lopatin</a>@author <a href="mailto:barataliba@gmail.com">Baratali Izmailov</a>
CustomDeclarationOrderCheck.fieldPrefix = Prefix of field's name.
CustomDeclarationOrderCheck.customDeclarationOrder = Regular expression, which sets the order of the parts of a class(main, nested, member inner).
CustomDeclarationOrderCheck.caseSensitive = Set false to ignore case.

ConfusingConditionCheck.name = Confusing Condition
ConfusingConditionCheck.desc = This check prevents negation within an "if" expression if "else" is present.<br>For example, rephrase: <br> if (x != y) smth1();<br> else smth2(); <br>as:<br> if (x == y) smth2(); <br>else smth1();
ConfusingConditionCheck.multiplyFactorForElseBlocks = Disable warnings if "else" block length is in "multiplyFactorForElseBlocks"  time less then "if" block.
ConfusingConditionCheck.ignoreInnerIf = Disable warnings for all inner "if" . It is useful for save similarity.
ConfusingConditionCheck.ignoreSequentialIf = Disable warnings for all sequential "if" . It is useful for save similarity.
ConfusingConditionCheck.ignoreNullCaseInIf = Disable warnings for "if" if it expression contains "null".
ConfusingConditionCheck.ignoreThrowInElse = Disable warnings for "if" if "else" block contain "throw".

EmptyPublicCtorInClassCheck.name = Empty Public Ctor In Class
EmptyPublicCtorInClassCheck.desc = <p>This Check looks for useless empty public constructors. Class constructor is considered useless by this Check if and only if class has exactly one ctor, which is public, empty(one that has no statements) and <a href="http://docs.oracle.com/javasespecs/jls/se8/html/jls-8.html#jls-8.8.9"> default</a>.</p><p>Example 1. Check will generate violation for this code:<pre><code>class Dummy {<br>    public Dummy() {<br>    }<br>}</code></pre></p><p>Example 2. Check will not generate violation for this code:<pre><code>class Dummy {<br>    private Dummy() {<br>    }<br>}</code></pre>class Dummy has only one ctor, which is not public.</p><p>Example 3. Check will not generate violation for this code:<pre><code>class Dummy {<br>   public Dummy() {<br>    }<br>    public Dummy(int i) {<br>    }<br>}</code></pre>class Dummy has multiple ctors.</p><p>Check has two properties:</p><p>"classAnnotationNames" - This property contains regex for canonical names of class annotations,which require class to have empty public ctor. Check will not log violations for classes marked with annotations that match this regex. Default option value is "javax\\.persistence\\.Entity".</p><p>"ctorAnnotationNames" - This property contains regex for canonical names of ctor annotations,which make empty public ctor essential. Check will not log violations for ctors marked with annotations that match this regex. Default option value is "com\\.google\\.inject\\.Inject".</p>@author <a href="mailto:zuy_alexey@mail.ru">Zuy Alexey</a>
EmptyPublicCtorInClassCheck.classAnnotationNames = Regex which matches names of class annotations which require class to have public no-argument ctor. Default value is "javax\\.persistence\\.Entity".
EmptyPublicCtorInClassCheck.ctorAnnotationNames = Regex which matches names of ctor annotations which make empty public ctor essential. Default value is "com\\.google\\.inject\\.Inject".

FinalizeImplementationCheck.name = Finalize Implementation
FinalizeImplementationCheck.desc = <p>This Check detects 3 most common cases of incorrect finalize() method implementation:</p><ul><li>negates effect of superclass finalize<br/><code>protected void finalize() { } <br/> protected void finalize() { doSomething(); }</code></li><li>useless (or worse) finalize<br/><code>protected void finalize() { super.finalize(); }</code></li><li>public finalize<br/><code>public void finalize() { try { doSomething(); } finally { super.finalize() } }</code></li></ul>

ForbidCertainImportsCheck.name = Forbid Certain Imports
ForbidCertainImportsCheck.desc = Forbids certain imports usage in certain packages. <br/><br/>You can configure this check using following parameters:<ol><li>Package qualified name regexp;</li><li>Forbidden imports regexp;</li><li>Forbidden imports excludes regexp.</li></ol>This check reads packages and imports qualified names without words "package","import" and semicolons, so, please, do NOT include "package" or "import" words or semicolons into your regular expressions when configuring.<br/><br/>Real-life example of usage: forbid to use all "*.ui.*" packages in "*.dao.*" packages, but ignore all Exception imports (such as <b>org.springframework.dao.InvalidDataAccessResourceUsageException</b>). For doing that, you should use the following check parameters: <br/><br/><dl><li>Package name regexp = ".*ui.*"</li><li>Forbidden imports regexp = ".*dao.*"</li><li>Forbidden imports excludes regexp = "^.+Exception$"</li></dl><br/>By means of few instances of this check will be possible to cover any rules.<br/><br/>Author: <a href="https://github.com/daniilyar"> Daniil Yaroslavtsev</a>
ForbidCertainImportsCheck.packageNameRegexp = Package name regexp.
ForbidCertainImportsCheck.forbiddenImportsRegexp = Regexp for matching forbidden imports
ForbidCertainImportsCheck.forbiddenImportsExcludesRegexp = Regexp for excluding imports from checking

ForbidCertainMethodCheck.name = Forbid Certain Method
ForbidCertainMethodCheck.desc = Forbids certain method usage. <br/><br/>You can configure this check using following parameters:<ol><li>Method name regexp;</li><li>Argument count range;</li></ol>This check reads method & constructor names without class/object name, so, please, do NOT include class/variable name in your regular expressions when configuring.<br/><br/>Real-life example of usage: forbid to use all "exit" method, forbid use of assertTrue/assertFalse with 1 parameter. For doing that, you should use the following check parameters: <br/><br/><dl><li>Method name regexp = "assert(True|False)"</li><li>Argument count range = "1"</li></dl><br/><br/>. Argument count can be bounded range(e.g.: 2-4) or unbounded range(e.g.: -5, 6-). Unbounded range can be unbounded only on one side. Multiple ranges must be comma separated. Author: <a href="https://github.com/raghavgautam"> Raghav Kumar Gautam</a>
ForbidCertainMethodCheck.methodName = Regex to match name of the forbidden method. When blank or unspecified, all the methods will be allowed.
ForbidCertainMethodCheck.argumentCount = Number or range to match number of arguments the forbidden method takes. Multiple ranges are separated by comma. When blank or unspecified, only method name will be used for check.

ForbidInstantiationCheck.name = Forbid Instantiation
ForbidInstantiationCheck.desc = Forbids instantiation of certain object types by their full classname.<br><p>For example:<br>"java.lang.NullPointerException" will forbid the NPE instantiation.</p><p>Note: className should to be full: use "java.lang.NullPointerException" instead of "NullpointerException".</p>
ForbidInstantiationCheck.forbiddenClasses = ClassNames for objects that are forbidden to instantiate.

ForbidCCommentsInMethodsCheck.name = Forbid C comments in method body
ForbidCCommentsInMethodsCheck.desc = Forbid C-style comments (/* ... */) in method body.

ForbidReturnInFinallyBlockCheck.name = Forbid return statement in finally block
ForbidReturnInFinallyBlockCheck.desc = Verifies the finally block design

ForbidThrowAnonymousExceptionsCheck.name = Forbid Throw Anonymous Exceptions
ForbidThrowAnonymousExceptionsCheck.desc = <p>This Check warns on throwing anonymous exception.<br>Examples:<p><code><pre> catch (Exception e)  {<br>     throw new RuntimeException()  {  //WARNING<br>          //some code<br>     };<br> }<br><br> catch (Exception e)  {<br>     RuntimeException run = new RuntimeException()  {<br>          //some code<br>     };<br>     throw run;  //WARNING<br> }<br></code></pre>The distinguishing of <b>exception</b> types occurs by analyzing variable's class's name.<br>Check has an option which contains the regular expression for exception class name matching<br>Default value is "^.*Exception" because usually exception type ends with suffix "Exception".<br>Then, if we have an ObjBlock (distinguished by curly braces), it's anonymous<br>exception definition. It could be defined in <b>throw</b> statement immediately.<br>In that case, after literal new, there would be an expression type finishing with and ObjBlock.<br><br>@author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a><br>@author <a href="mailto:maxvetrenko2241@gmail.com">Max Vetrenko</a>
ForbidThrowAnonymousExceptionsCheck.exceptionClassNameRegex = Regex for exception class name matching

DiamondOperatorForVariableDefinitionCheck.name = Diamond Operator For Variable Definition
DiamondOperatorForVariableDefinitionCheck.desc = This Check highlights variable definition statements where <a href= "http://docs.oracle.com/javase/7/docs/technotes/guides/language/type-inference-generic-instance-creation.html"> diamond operator</a> could be used.<br> <b>Rationale</b>: using diamond operator (introduced in Java 1.7) leads to shorter code<br> and better code readability. It is suggested by Oracle that the diamond primarily using<br> for variable declarations.<br><br> E.g. of statements: <p> <b>Without diamond operator:</b><br><code> Map&ltString, Map&ltString, Integer&gt&gt someMap = new HashMap&ltString, Map&ltString, Integer&gt&gt();</code><br> <b>With diamond operator:</b><br> <code> Map&ltString, Map&ltString, Integer&gt&gt someMap = new HashMap&lt&gt(); </code> </p> @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>

IllegalCatchExtendedCheck.name = Illegal Catch Extended
IllegalCatchExtendedCheck.desc = Check for illegal catch but with option to ignore these catches in some cases
IllegalCatchExtendedCheck.allowThrow = Allow catching when throwing some exception
IllegalCatchExtendedCheck.allowRethrow = Allow catching when re-throwing exception
IllegalCatchExtendedCheck.illegalClassNames = Illegal class names

LogicConditionNeedOptimizationCheck.name = Logic condition need optimization
LogicConditionNeedOptimizationCheck.desc = This check prevents the placement of local variables and fields after calling methods in '&&' and '||' conditions.

MapIterationInForEachLoopCheck.name = Map Iteration In For Each Loop 
MapIterationInForEachLoopCheck.desc = This check can help you to write the whole for-each map iteration more correctly:<ol><li> If you iterate over a map using map.keySet() or map.entrySet(), but your code uses only map values, Check will propose you to use map.values() instead of map.keySet() or map.entrySet(). Replacing map.keySet() or map.entrySet() with map.values() for such cases can a bit improve an iteration performance. <p>Bad:</p><pre>for (Map.Entry<String, String>; entry : map.entrySet()){<br/>   System.out.println(entry.getValue());<br/>}</pre><pre>for (String key : map.keySet(){<br/>   System.out.println(map.get(key));<br/>}</pre><p>Good:</p><pre>for (String value : map.values()){<br/>   System.out.println(value);<br/>}</pre> </li><li>If you iterate over a map using map.entrySet(), but never call entry.getValue(), Check will propose you to use map.keySet() instead of map.entrySet(). to iterate over map keys only. <p>Bad:</p><pre>for (Map.Entry<String, String> entry : map.entrySet()){<br/>   System.out.println(entry.getKey());<br/>}</pre><p>Good:</p><pre>for (String key : map.keySet()){<br/>   System.out.println(key);<br/>}</pre></li><li>If you iterate over a map with map.keySet() and use both keys and values, check will propose you to use map.entrySet() to improve an iteration performance by avoiding search operations inside a map. For this case, iteration can significantly grow up a performance. <p>Bad:</p><pre>for (String key : map.keySet()){<br/>   System.out.println(key + "  " + map.get(key));<br/>}</pre><p>Good:</p><pre>for (Map.Entry<String, String> entry : map.entrySet()){<br/>   System.out.println(entry.getValue() + "   " + entry.getKey());<br/>}</pre></li></ol>
MapIterationInForEachLoopCheck.supportedMapImplQualifiedNames = Enter your own Map implementations.
MapIterationInForEachLoopCheck.proposeValuesUsage = If this checkbox is checked, Check will propose to replace wrong usage to value().
MapIterationInForEachLoopCheck.proposeKeySetUsage = If this checkbox is checked, Check will propose to replace wrong usage to keySet().
MapIterationInForEachLoopCheck.proposeEntrySetUsage = If this checkbox is checked, Check will propose to replace wrong usage to entrySet().

MultipleVariableDeclarationsExtendedCheck.name = Multiple Variable Declarations Extended
MultipleVariableDeclarationsExtendedCheck.desc = Warn when declaring several variables in one line
MultipleVariableDeclarationsExtendedCheck.ignoreCycles = Turning on this option makes check not to warn on multiple variable definitions inside cycles.   
MultipleVariableDeclarationsExtendedCheck.ignoreMethods = Turning on this option makes check not to warn on multiple variable definitions inside methods.

MultipleStringLiteralsExtendedCheck.allowedDuplicates = The maximum number of occurences to allow without generating a warning
MultipleStringLiteralsExtendedCheck.desc = Checks for multiple occurrences of the same string literal within a single file.<br/>\r\nRationale: Code duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.
MultipleStringLiteralsExtendedCheck.ignoreOccurrenceContext = Token type names where duplicate strings are ignored even if they don't match ignoredStringsRegexp. This allows you to exclude syntactical contexts like Annotations or static initializers from the check.
MultipleStringLiteralsExtendedCheck.ignoreStringsRegexp = Regexp pattern for ignored strings (with quotation marks)
MultipleStringLiteralsExtendedCheck.name = Multiple String Literals Extended
MultipleStringLiteralsExtendedCheck.highlightAllDuplicates = Check to highlight all dublicates

TernaryPerExpressionCountCheck.name = Ternary Per Expression Count
TernaryPerExpressionCountCheck.desc = Restricts the number of ternary operators in expression to a specific limit.<br><br><b>Rationale:</b> This Check helps to improve code readability by pointing developer on<br>expressions which contain more than user-defined count of ternary operators.<br><br>It points to complicated ternary <a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html">expressions</a>. Reason:<br>- Complicated ternary expressions are not easy to read.<br>- Complicated ternary expressions could lead to ambiguous result if user<br>does not know Java's operators priority well, e.g.:<br><p><code>String str = null;<br>String x = str != null ? "A" : "B" + str == null ? "C" : "D";<br>System.out.println(x);</code></p>Output for code above is "D", but more obvious would be "BC".<br></p>Check has following properties:<br><ul><li><b>maxTernaryPerExpressionCount</b> - limit of ternary operators perexpression<br></li><li><b>ignoreTernaryOperatorsInBraces</b> - if true Check will ignore ternary operators<br>in braces (braces explicitly set priority level)<br></li><li><b>ignoreIsolatedTernaryOnLine</b> - if true Check will ignore one line ternary operators,<br>if only it is places in line alone.<br> </li></ul>Options <b>ignoreTernaryOperatorsInBraces</b> and <b>ignoreIsolatedTernaryOnLine</b> can<br>make Check less strict, e.g.:<br>Using <b>ignoreTernaryOperatorsInBraces</b> option (value = <b>true</b>)<br>does not put violation on code below:<br><p><code><pre>callString = "{? = call " +<br>  (StringUtils.hasLength(catalogNameToUse)   ? catalogNameToUse + "." : "") +<br>  (StringUtils.hasLength(schemaNameToUse)   ? schemaNameToUse + "." : "") +<br>  procedureNameToUse + "(";<br></pre></code></p>When using <b>ignoreIsolatedTernaryOnLine</b> (value = <b>true</b>), even without<br><b>ignoreTernaryOperatorsInBraces</b> option Check won't warn on code below:<br> <p><code><pre>int a = (d == 5) ? d : f<br>  +<br>  ((d == 6) ? g : k);</pre></code></p>@author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
TernaryPerExpressionCountCheck.maxTernaryPerExpressionCount = Maximum number of ternary operators in expression
TernaryPerExpressionCountCheck.ignoreTernaryOperatorsInBraces = Ignore ternary operators in expression in case if priority level is set explicitly
TernaryPerExpressionCountCheck.ignoreIsolatedTernaryOnLine = Ignore ternary operators in expression in case if ternary operator is isolated in line 

NameConventionForJunit4TestClassesCheck.name = Name Convention For JUnit4 Test Classes Check
NameConventionForJunit4TestClassesCheck.desc = <p>This check verifies the name of JUnit4 test class for compliance with user defined naming convention(by default Check expects test classes names matching ".+Test\\d*|.+Tests\\d*|Test.+|Tests.+|.+IT|.+ITs|.+TestCase\\d*|.+TestCases\\d*" regex). </p> <p> Class is considered to be a test if its definition or one of its method definitions annotated with user defined annotations. By default Check looks for classes which contain methods annotated with "Test" or "org.junit.Test". </p> <p> Check has following options: </p> <p> "expectedClassNameRegex" - regular expression which matches expected test class names. If test class name does not matches this regex then Check will log violation. This option defaults to ".+Test\\d*|.+Tests\\d*|Test.+|Tests.+|.+IT|.+ITs|.+TestCase\\d*|.+TestCases\\d*". </p> <p> "classAnnotationNameRegex" - regular expression which matches test annotation names on classes. If class annotated with matching annotation, it is considered to be a test. This option defaults to empty regex(one that matches nothing). If for example this option set to "RunWith", then class "SomeClass" is considered to be a test: <pre> <code>@RunWith(Parameterized.class)<br> class SomeClass<br> {<br> }<br> </code> </pre> </p> <p>"methodAnnotationNameRegex" - regular expression which matches test annotation names on methods. If class contains a method annotated with matching annotation, it is considered to be a test. This option defaults to "Test|org.junit.Test". For example, if this option set to "Test", then class SomeClass" is considered to be a test.  <pre> <code> class SomeClass<br>  {<br>     @Test<br>     void method() {<br>     <br>     }<br>  }<br></code></pre></p><p>Annotation names must be specified exactly the same way it specified in code, thus if Check must match annotation with fully qualified name, corresponding options must contain qualified annotation name and vice versa. For example, if annotation regex is "org.junit.Test" Check will recognize "@org.junit.Test" annotation and will skip "@Test" annotation and vice versa if annotation regex is "Test" Check will recognize "@Test" annotation and skip "@org.junit.Test" annotation. </p>@author <a href="mailto:zuy_alexey@mail.ru">Zuy Alexey</a>
NameConventionForJunit4TestClassesCheck.expectedClassNameRegex = Regular expression which matches expected test class names.
NameConventionForJunit4TestClassesCheck.classAnnotationNameRegex = Regular expression which matches test annotation names on classes.
NameConventionForJunit4TestClassesCheck.methodAnnotationNameRegex = Regular expression which matches test annotation names on methods.

NoNullForCollectionReturnCheck.name = No null for collection return
NoNullForCollectionReturnCheck.desc = Check report you, when method, that must return array or collection, return null value instead of empty collection or empty array.
NoNullForCollectionReturnCheck.collectionList = List of the collections that will be check
NoNullForCollectionReturnCheck.searchThroughMethodBody = Search null value not only into return block

NumericLiteralNeedsUnderscoreCheck.name = Numeric Literal Needs Underscore
NumericLiteralNeedsUnderscoreCheck.desc = Warn that long numeric literals should be spaced by underscores.
NumericLiteralNeedsUnderscoreCheck.minDecimalSymbolLength = The minimum number of symbols in a decimal literal before the check begins to look for underscores
NumericLiteralNeedsUnderscoreCheck.maxDecimalSymbolsUntilUnderscore = The maximum number of symbols in a decimal literal allowed before the check demands an underscore
NumericLiteralNeedsUnderscoreCheck.minHexSymbolLength = The minimum number of symbols in a hex literal before the check begins to look for underscores
NumericLiteralNeedsUnderscoreCheck.maxHexSymbolsUntilUnderscore = The maximum number of symbols in a hex literal allowed before the check demands an underscore
NumericLiteralNeedsUnderscoreCheck.minBinarySymbolLength = The minimum number of symbols in a binary literal before the check begins to look for underscores
NumericLiteralNeedsUnderscoreCheck.maxBinarySymbolsUntilUnderscore = The maximum number of symbols in a binary literal allowed before the check demands an underscore
NumericLiteralNeedsUnderscoreCheck.ignoreFieldNamePattern = Regexp for fields to ignore

OverridableMethodInConstructorCheck.desc = <p>Prevents any calls to overridable methods that are take place in:<ol><li>Any constructor body (verification is always done by default and not configurable).<li>Any method which works same as a constructor: clone() method from Cloneable interface and readObject() method from Serializable interface (you can individually switch on/of these methods verification by changing CheckCloneMethod and CheckReadObjectMethod properties).</li></ol><p>Rationale:<ol><li><q>Constructors must not invoke overridable methods, directly or indirectly.If you violate this rule, program failure will result. The superclass constructor runs before the subclass constructor, so the overriding method in the subclass will be invoked before the subclass constructor has run. If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected.</q><li><q>If you do decide to implement Cloneable or Serializable in a class designed for inheritance, you should be aware that because the clone() and readObject() methods behave a lot like constructors, a similar restriction applies: neither clone nor readObject may invoke an overridable method, directly or indirectly.</q></ol></p><br><p align="right">[Joshua Bloch - Effective Java 2nd Edition,Chapter 4, Item 17]</p><br>
OverridableMethodInConstructorCheck.name = Overridable Method In Constructor
OverridableMethodInConstructorCheck.checkCloneMethod = Enables the searching of calls to overridable methods from body of any clone() method is implemented from Cloneable interface.
OverridableMethodInConstructorCheck.checkReadObjectMethod = Enables the searching of calls to overridable methods from the body of any readObject() method is implemented from Serializable interface.
OverridableMethodInConstructorCheck.matchMethodsByArgCount = Enables matching methods by number of their parameters

ReturnBooleanFromTernaryCheck.name = Returning Boolean from Ternary Operator
ReturnBooleanFromTernaryCheck.desc = Avoid returning boolean values from ternary operator - use the boolean value from the inside directly.

ReturnCountExtendedCheck.name=Return Count Extended
ReturnCountExtendedCheck.desc=Checks that method/ctor "return" literal count is not greater than the given value ("maxReturnCount" property).<br><br>Rationale:<br><br>One return per method is a good practice as its ease understanding of method logic.<br><br>Reasoning is that:<dl><li>It is easier to understand control flow when you know exactly where the method returns.<li>Methods with 2-3 or many "return" statements are much more difficult to understand, debug and refactor.</dl>Setting up the check options will make it to ignore:<ol><li>Methods by name ("ignoreMethodsNames" property). Note, that the "ignoreMethodsNames" property type is NOT regexp: using this property you can list the names of ignored methods separated by comma.</li><li>Methods which linelength less than given value ("linesLimit" property).<li>"return" statements which depth is greater or equal to the given value ("returnDepthLimit" property). There are few supported<br>coding blocks when depth counting: "if-else", "for", "while"/"do-while" and "switch".<li>"Empty" return statements = return statements in void methods and ctors that have not any expression ("ignoreEmptyReturns" property).<li>Return statements, which are located in the top lines of method/ctor (you can specify the count of top method/ctor lines that will be ignored using "rowsToIgnoreCount" property).</ol>So, this is much improved version of the existing <i>Return Count</i> check.<br><br>
ReturnCountExtendedCheck.maxReturnCount=maximum allowed number of return statements per method/ctor (1 by default).
ReturnCountExtendedCheck.ignoreMethodLinesCount=Option to ignore methods/ctors which body has the linelength is less than given (20 lines by default). Set "0" to switch this option off and check all methods/ctors.
ReturnCountExtendedCheck.minIgnoreReturnDepth=Option to ignore methods/ctors that have return statement(s) with depth value is less than N levels(scopes). 4 by default. 0 is the min depth. Depth is 0 when the "return" statement is not wrapped on one of the supported coding blocks. 
ReturnCountExtendedCheck.ignoreEmptyReturns=Option to ignore "empty" (with no any expression) return statements in void methods and ctors. 'False' by default.
ReturnCountExtendedCheck.topLinesToIgnoreCount=Option to set the count of code lines that will be ignored in top of all methods.
ReturnCountExtendedCheck.ignoreMethodsNames=Option to set the RegExp patterns for methods' names which would be ignored by check.

ReturnNullInsteadOfBooleanCheck.name = Returning Null Instead of Boolean
ReturnNullInsteadOfBooleanCheck.desc = Method declares to return Boolean, but returns null

RedundantReturnCheck.name=Redundant Return
RedundantReturnCheck.desc=<p>Highlight usage redundant returns inside constructors and methods with void result.</p><p>For example:</p><p>1. Non empty constructor</p><code><pre>public HelloWorld(){<br/>    doStuff();<br/>    return;<br/>}</pre></code><p>2. Method with void result</p><code><pre>public void testMethod1(){<br/>    doStuff();<br/>    return;<br/>}</pre></code><p>However, if your IDE does not support breakpoints on the method entry, you can allow the use of redundant returns in constructors and methods with void result without code except for 'return;'.</p><p>For example:</p><p>1. Empty constructor</p><code><pre>public HelloWorld(){<br/>    return;<br/>}</pre></code><p>2. Method with void result and empty body</p><code><pre>public void testMethod1(){<br/>    return;<br/>}</pre></code>@author <a href="mailto:nesterenko-aleksey@list.ru">Alexey Nesterenko</a><br>@author <a href="mailto:fishh1991@gmail.com">Troshin Sergey</a><br>@author <a href="mailto:maxvetrenko2241@gmail.com">Max Vetrenko</a>
RedundantReturnCheck.allowReturnInEmptyMethodsAndConstructors=If True, allow 'return' in empty constructors and methods that return void.

SimpleAccessorNameNotationCheck.name=Simple Accessor Name Notation
SimpleAccessorNameNotationCheck.desc=This check verify incorrect name of setter or getter methods if it used field with other name. For example, method has name 'setXXX', but define field with name 'YYY'
SimpleAccessorNameNotationCheck.prefix=prefix of field's name

SingleBreakOrContinueCheck.name = Single break or continue inside a loop
SingleBreakOrContinueCheck.desc = <p>This check restricts the number of break and continue statements inside cycle body (only one is allowed).</p><p>Restricting the number of break and continue statements in a loop is done in the interest of good structured programming.</p>

UnnecessaryParenthesesExtendedCheck.desc = Checks for the use of unnecessary parentheses.
UnnecessaryParenthesesExtendedCheck.name = Unnecessary Parentheses Extended
UnnecessaryParenthesesExtendedCheck.ignoreCalculationOfBooleanVariables =           Cancel validation setups of unnecessary parentheses in Boolean computations.
UnnecessaryParenthesesExtendedCheck.ignoreCalculationOfBooleanVariablesWithReturn = Cancel validation setups of unnecessary parentheses in Boolean computations with return state.
UnnecessaryParenthesesExtendedCheck.ignoreCalculationOfBooleanVariablesWithAssert = Cancel validation setups of unnecessary parentheses in Boolean computations with assert state.

UselessSingleCatchCheck.desc = <p>Checks for the presence of useless single catch blocks.</p><p>Catch block can be considered useless if it is the only catch block for try,contains only one statement which rethrows catched exception. Fox example:</p> <code> try {<br>     ...<br> }<br> catch(Exception e) {<br>     throw e;<br> }<br> </code>
UselessSingleCatchCheck.name = Useless single catch check

UselessSuperCtorCallCheck.name = Useless super constructor call
UselessSuperCtorCallCheck.desc = <p>Checks for useless "super()" calls in ctors.</p><p>"super()" call could be considered by Check as "useless" in two cases:</p><p>Case 1. no-argument "super()" is called from class ctor if class is not derived, for example:<pre><code>class Dummy {<br>    Dummy() {<br>            super();<br>    <br>}</code></pre>"super()" call is useless because class "Dummy" is not derived.<p>Case 2. no-argument "super()" is called without parameters from class ctor if class is derived, for example:<pre><code>class Derived extends Base {<br>    Derived() {<br>            super();<br>    }<br>}</code></pre>Java compiler automatically inserts a call to the no-args constructor of the super class, so there is no need to call super ctor explicitly. Check has options "allowCallToNoArgsSuperCtor" and "allowCallToNoArgsSuperCtorIfMultiplePublicCtor" to adjust check behavior for such cases(see Check`s options description for details).</p><p>Check has following options:</p><p>"allowCallToNoArgsSuperCtor" - if this option set to true, Check will not generate violations when "super()" called inside derived class. This option defaults to "false". If for example this option set to "true", then Check will not generate violation for cases like following:<pre><code>class Base {<br>    public Base() {<br>    }<br>}<br><br>class Derived extends Base {<br>   public Derived() {<br>        super();<br>    }<br>}</code></pre></p><p>"allowCallToNoArgsSuperCtorIfMultiplePublicCtor" - if this option set to "true",then Check will not generate violation when "super()" called inside class ctor when class has multiple public ctors(however, setting this option to"true" will not prevent Check from logging violation if class does not extend anything). This option defaults to "false". This option may be usefull for cases in which class`s ctors just forward its arguments to super ctors, thus removing "super()" in this case will make default ctors look not like others.For example:<pre><code>class Base {<br>    public Base() {<br>    }<br><br>    public Base(int i) {<br>    }<br>}<br><br>class Derived extends Base {<br>    public Derived() {<br>        super(); // this "super()" will not be considered useless if option is set to true,<br>                 // because "Derived" has multiple public ctors. <br>    }<br><br>    public Derived(int i) {<br>        super(i); // this "super()" will not be considered useless if option is set to true,<br>                  // because "Derived" has multiple public ctors.<br>    }<br>}<br><br>class NotDerived{<br>   public NotDerived() {<br>        super(); // this "super()" will be considered useless regardless of option value,<br>                 // because "NotDerived" does not extend anything.<br>    }<br>    public NotDerived(int i) {<br>        super(); // this "super()" will be considered useless regardless of option value,<br>                 // because "NotDerived" does not extend anything.<br>    }<br>}</code></pre></p>@author <a href="mailto:zuy_alexey@mail.ru">Zuy Alexey</a>
UselessSuperCtorCallCheck.allowCallToNoArgsSuperCtor = Allow calls to no-arguments super constructor from derived class.
UselessSuperCtorCallCheck.allowCallToNoArgsSuperCtorIfMultiplePublicCtor = Allow calls to no-arguments super constructor from derived class if it has multiple public constructors.

EitherLogOrThrowCheck.desc =  <p>Either log the exception, or throw it, but never do both. Logging and throwing results in multiple log messages for a single problem in the code, and makes problems for the support engineer who is trying to dig through the logs. This is one of the most annoying error-handling antipatterns. All of these examples are equally wrong.</p><p><b>Examples:</b><pre>catch (NoSuchMethodException e) {\t\nLOG.error("Message", e);\t\nthrow e;\n}</pre><b>or</b><pre>catch (NoSuchMethodException e) {\t\nLOG.error("Message", e);\t\nthrow new MyServiceException("AnotherMessage", e);\n}</pre><b>or</b><pre>catch (NoSuchMethodException e) {\t\ne.printStackTrace();\t\nthrow new MyServiceException("Message", e);\n}</pre></p><p><b>What check can detect:</b> <br><b>Loggers</b><ul><li>logger is declared as class field</li><li>logger is declared as method's local variable</li><li>logger is declared as local variable in <code>catch</code> block</li><li>logger is passed through method's parameters</li></ul><b>Exceptions</b><ul><li>logger logs <code>catch</code> parameter exception or it's message</li><li>throw <code>catch</code> parameter exception</li><li>throw another exception which is based on <code>catch</code> parameter exception</li><li>printStackTrace was called on <code>catch</code> parameter exception</li></ul></p><b>What check can not detect:</b> <br><ul><li>loggers that is used like method's return value. Example:<pre>getLogger().error(&quot;message&quot;, e)</pre></li> <li>loggers that is used like static fields from another classes:<pre>MyAnotherClass.LOGGER.error("message", e);<pre></li></ul></p><p>Default parameters are:<ul><li><b>loggerFullyQualifiedClassName</b> - fully qualified class name of logger type. Default value is <i>"org.slf4j.Logger"</i>.</li><li><b>loggingMethodNames</b> - comma separated names of logging methods. Default value is <i>"error, warn, info, debug"</i>.</li></ul></p><p>Note that check works with only one logger type. If you have multiple different loggers, then create another instance of this check.</p>
EitherLogOrThrowCheck.name = Either log exception or throw exception.
EitherLogOrThrowCheck.loggerFullyQualifiedClassName = Logger fully qualified class name. Example: "org.slf4j.Logger".
EitherLogOrThrowCheck.loggingMethodNames = Logging method names separated with commas. Example: "error,warn". 

WhitespaceBeforeArrayInitializerCheck.name = Whitespace Before Array Initializer
WhitespaceBeforeArrayInitializerCheck.desc = This checks enforces whitespace before array initializer.

MoveVariableInsideIfCheck.name = Move Variable Inside If Check
MoveVariableInsideIfCheck.desc = Checks if a variable is only used inside if statements and asks for it's declaration to be moved there too.

RequireFailForTryCatchInJunitCheck.name = Require Fail For Try/Catch in JUnit Check
RequireFailForTryCatchInJunitCheck.desc = Checks if a try/catch block has a junit fail assertion inside the try  for a junit method.
