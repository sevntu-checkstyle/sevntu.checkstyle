CauseParameterInException.name = Cause Parameter In Exception
CauseParameterInException.desc = Checks that any Exception class which matches the defined className regexp have at least one constructor with Exception cause as a parameter.<br><br>Parameters:<dl><li>Exception classNames regexp. ("classNamesRegexp" option)</li><li>regexp to ignore classes by names ("ignoredClassNamesRegexp" option).</li><li>The names of classes which would be considered as Exception cause ("allowedCauseTypes" option).</li><br></dl>
CauseParameterInException.classNamesRegexp = The regexp for the names of classes, that should be checked. Default value = ".+Exception".
CauseParameterInException.ignoredClassNamesRegexp = The regexp for the names of classes, that should be ignored by check.
CauseParameterInException.allowedCauseTypes = The names of classes which would be considered as Exception cause, separated by comma. Default value = "Throwable, Exception".

ChildBlockLength.name = Child Block Length
ChildBlockLength.desc = This check detects the child blocks, which length is more then 80% of parent block length.<br><p>Supported keywords are used to detect blocks:<br>"if", "else", "for", "switch", "do", "while", "try", "catch".</p><p><i>Rationale:</i></p><p>Length of child block that is more then 80% of parent block is usually hard to read in case child block is long(few display screens). Such child blocks should be refactored or moved to separate method.
ChildBlockLength.allowedBlockTypes = Option to switch the block types that will be checked. 
ChildBlockLength.maxChildBlockPercentage = Maximum percentage ratio between the child block and the parent block. Default value = 80%;
ChildBlockLength.ignoreBlockLinesCount = Maximum number of lines of which block body may consist to be skipped by check.

NoMainMethodInAbstractClass.name = No Main Method In Abstract Class
NoMainMethodInAbstractClass.desc = Forbids main methods in abstract classes. Rationale: existance of 'main' method can mislead a developer to consider this class as a ready-to-use implementation.

ForbidWildcardAsReturnType.name = Forbid Wildcard As Return Type
ForbidWildcardAsReturnType.desc = Prevents using wildcards as return type of methods.<p><i>Joshua Bloch, "Effective Java (2nd edition)" Item 28: page 137 :</i></p> <p>"Do not use wildcard types as return types. Rather than providing additional flexibility for your users, it would force them to use wildcard types in client code. Properly used, wildcard types are nearly invisible to users of a class. They cause methods to accept the parameters they should accept and reject those they should reject. If the user of a class has to think about wildcard types, there is probably something wrong with the class\u2019s API."</p>
ForbidWildcardAsReturnType.checkPublicMethods = Check public methods 
ForbidWildcardAsReturnType.checkPackageMethods = Check protected-package methods
ForbidWildcardAsReturnType.checkProtectedMethods = Check protected methods
ForbidWildcardAsReturnType.checkPrivateMethods = Check private methods
ForbidWildcardAsReturnType.checkOverrideMethods = Check override methods
ForbidWildcardAsReturnType.checkDeprecatedMethods = Check deprecated methods
ForbidWildcardAsReturnType.allowReturnWildcardWithSuper = Allow wildcard with "super". Example: "? super T"
ForbidWildcardAsReturnType.allowReturnWildcardWithExtends = Allow wildcard with "extends". Example: "? extends T"
ForbidWildcardAsReturnType.returnTypeClassNamesIgnoreRegex = Ignore regex for return type class names

PublicReferenceToPrivateTypeCheck.name = Public Reference To Private Type
PublicReferenceToPrivateTypeCheck.desc = <p>This Check warns on propagation of inner private types to outer classes:<br>- Externally accessible method if it returns private inner type.<br>- Externally accessible field if it's type is a private inner type.<br>These types could be <a href='http://docs.oracle.com/javase/tutorial/java/javaOO/nested.html'>private inner classes</a>, interfaces or enumerations.<br><br>Examples:<code><pre> class OuterClass {<br><br>  public InnerClass innerFromMain = new InnerClass(); //WARNING<br>  private class InnerClass { ... }<br>  public InnerClass  getValue() { //WARNING<br>      return new InnerClass();<br>  }<br><br>  private interface InnerInterface { ... }<br>  public Set&ltInnerInterface&gt getValue() { //WARNING<br>      return new TreeSet&ltInnerInterface&gt;;<br>  }<br><br>  private Enum Fruit {Apple, Pear}<br>  public Fruit getValue() { //WARNING<br>      return Fruit.Apple;<br>  }<br><br>  public someMethod(InnerClass innerClass) { ... }  //WARNING<br><br> }</pre></code><b>Rationale:</b> it is possible to return<br>private inner type or use it as the parameter of non-private method, but it is impossible<br>to use it in other classes (besides inner classes)<br>unless it extends or implements at least one <u>non-private</u> class or interface.<br>Such situation usually happens after bulk refactoring and usually means dead/useless code<br></p><br>@author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>